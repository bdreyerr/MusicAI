//
//  GridContentView.swift
//  music.ai.frontend
//
//  Created by Ben Dreyer on 3/23/25.
//

import SwiftUI
import Combine

// Grid Content View for displaying grid lines and MIDI notes
struct GridContentView: View {
    @EnvironmentObject var themeManager: ThemeManager
    @ObservedObject var viewModel: MidiEditorViewModel
    let clip: MidiClip
    let keyHeight: CGFloat
    let pixelsPerBeat: CGFloat
    
    var body: some View {
        let clipWidth = CGFloat(clip.duration) * pixelsPerBeat
        let clipHeight = CGFloat(viewModel.fullEndNote - viewModel.fullStartNote + 1) * keyHeight
        
        ZStack {
            // Background grid
            Canvas { context, size in
                // Draw horizontal lines (one for each note)
                for i in 0...(viewModel.fullEndNote - viewModel.fullStartNote) {
                    let y = CGFloat(i) * keyHeight
                    let start = CGPoint(x: 0, y: y)
                    let end = CGPoint(x: clipWidth, y: y)
                    
                    let path = Path { p in
                        p.move(to: start)
                        p.addLine(to: end)
                    }
                    
                    // Thinner line for regular notes
                    context.stroke(path, with: .color(themeManager.gridLineColor), lineWidth: 0.5)
                }
                
                // Draw vertical lines (bars and beats)
                let bars = Int(ceil(clip.duration / Double(clip.timeSignature.beatsPerBar)))
                
                // Draw bar lines (thicker)
                for bar in 0...bars {
                    let x = CGFloat(bar * clip.timeSignature.beatsPerBar) * pixelsPerBeat
                    let start = CGPoint(x: x, y: 0)
                    let end = CGPoint(x: x, y: clipHeight)
                    
                    let path = Path { p in
                        p.move(to: start)
                        p.addLine(to: end)
                    }
                    
                    // Thicker line for bar divisions
                    context.stroke(path, with: .color(themeManager.barLineColor), lineWidth: 1.0)
                }
                
                // Draw beat lines (medium)
                for beat in 0...Int(clip.duration) {
                    let x = CGFloat(beat) * pixelsPerBeat
                    let start = CGPoint(x: x, y: 0)
                    let end = CGPoint(x: x, y: clipHeight)
                    
                    let path = Path { p in
                        p.move(to: start)
                        p.addLine(to: end)
                    }
                    
                    // Check if this is a bar line (we already drew it thicker)
                    let isBarLine = beat % clip.timeSignature.beatsPerBar == 0
                    
                    if !isBarLine {
                        // Medium line for beat divisions
                        context.stroke(path, with: .color(themeManager.beatLineColor), lineWidth: 0.75)
                    }
                }
                
                // Draw hover preview if active
                if let hoveredBeat = viewModel.hoveredBeat, let hoveredKey = viewModel.hoveredKey {
                    let noteX = CGFloat(hoveredBeat) * pixelsPerBeat
                    let noteY = CGFloat(viewModel.fullEndNote - hoveredKey) * keyHeight
                    
                    let noteRect = Path(CGRect(x: noteX, y: noteY, width: pixelsPerBeat, height: keyHeight))
                    
                    // Use a translucent color for hover preview
                    context.fill(noteRect, with: .color(themeManager.accentColor.opacity(0.3)))
                    context.stroke(noteRect, with: .color(themeManager.accentColor.opacity(0.7)), lineWidth: 1.0)
                }
            }
            
            // MIDI Notes Layer
            ForEach(clip.notes) { note in
                MidiNoteView(
                    note: note,
                    clipColor: clip.color ?? themeManager.accentColor,
                    keyHeight: keyHeight,
                    pixelsPerBeat: pixelsPerBeat,
                    onTap: {
                        viewModel.selectNote(note)
                    }
                )
                .position(
                    x: CGFloat(note.startBeat) * pixelsPerBeat + (CGFloat(note.duration) * pixelsPerBeat) / 2,
                    y: CGFloat(viewModel.fullEndNote - note.pitch) * keyHeight + keyHeight / 2
                )
            }
        }
        .frame(width: clipWidth, height: clipHeight)
        .contentShape(Rectangle())
        .onTapGesture { location in
            // Calculate note and beat position
            let beatPosition = Double(location.x / pixelsPerBeat)
            let noteNumber = viewModel.fullEndNote - Int(location.y / keyHeight)
            
            // Create and add a new note
            viewModel.addNoteToClip(
                clipID: clip.id, 
                pitch: noteNumber, 
                startBeat: Double(Int(beatPosition)), 
                duration: 1.0, 
                velocity: 100
            )
            
            // Update hover position for feedback
            viewModel.updateHoveredKey(noteNumber)
            viewModel.hoveredBeat = Int(beatPosition)
        }
        .gesture(
            DragGesture(minimumDistance: 0)
                .onChanged { value in
                    let location = value.location
                    
                    // Calculate beat position (x coordinate)
                    let beatPosition = Double(location.x / pixelsPerBeat)
                    viewModel.hoveredBeat = beatPosition >= 0 && beatPosition < clip.duration ? Int(beatPosition) : nil
                    
                    // Calculate note (y coordinate)
                    let calculatedNote = viewModel.fullEndNote - Int(location.y / keyHeight)
                    if calculatedNote >= viewModel.fullStartNote && calculatedNote <= viewModel.fullEndNote {
                        viewModel.updateHoveredKey(calculatedNote)
                    } else {
                        viewModel.updateHoveredKey(nil)
                    }
                }
                .onEnded { _ in
                    // Reset hover states when gesture ends
                    viewModel.hoveredBeat = nil
                    viewModel.updateHoveredKey(nil)
                }
        )
    }
}
